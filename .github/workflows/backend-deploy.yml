name: Backend Deploy via ECR

on:
  push:
    branches: [main]
    paths: ['backend/**']
  workflow_dispatch:

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-southeast-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd backend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Deploy to Auto Scaling Group via SSM
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Get all healthy instance IDs from ASG
        INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names ${{ secrets.ASG_NAME }} \
          --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
          --output text)
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "‚ùå No healthy instances found in ASG"
          exit 1
        fi
        
        IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "üöÄ Deploying image $IMAGE_URI to instances: $INSTANCE_IDS"
        
        # Deploy to all healthy instances
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_IDS \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"aws ecr get-login-password --region ap-southeast-1 | sudo docker login --username AWS --password-stdin $ECR_REGISTRY\",
            \"sudo docker stop \$(sudo docker ps -q) || true\",
            \"sudo docker rm \$(sudo docker ps -aq) || true\",
            \"sudo docker pull $IMAGE_URI\",
            \"sudo docker run -d --name jagasewa-backend -p 80:80 --restart unless-stopped -e AWS_DEFAULT_REGION=ap-southeast-1 -e DB_SECRET_NAME=jagasewa-db-credentials-prod $IMAGE_URI\",
            \"sudo docker system prune -f\"
          ]" \
          --region ap-southeast-1 \
          --query 'Command.CommandId' --output text)
        
        echo "üìã Command ID: $COMMAND_ID"
        echo "‚è≥ Waiting for deployment to complete..."
        
        # Wait for command completion
        aws ssm wait command-executed --command-id $COMMAND_ID --region ap-southeast-1
        
        # Check results
        FAILED_COUNT=$(aws ssm list-command-invocations --command-id $COMMAND_ID --region ap-southeast-1 --query 'length(CommandInvocations[?Status==`Failed`])' --output text)
        
        if [ "$FAILED_COUNT" -gt "0" ]; then
          echo "‚ùå Deployment failed on $FAILED_COUNT instances"
          aws ssm list-command-invocations --command-id $COMMAND_ID --region ap-southeast-1 --query 'CommandInvocations[?Status==`Failed`].{InstanceId:InstanceId,StatusDetails:StatusDetails}' --output table
          exit 1
        fi
        
        echo "‚úÖ Deployment completed successfully on all instances"